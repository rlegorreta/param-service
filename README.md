# <img height="25" src="./images/AILLogoSmall.png" width="40"/> param-service

<a href="https://www.legosoft.com.mx"><img height="150px" src="./images/Icon.png" alt="AI Legorreta" align="left"/></a>
Microservice that acts as the system general parameters repository.

The `param-service` stores all generic parameters in a Postgres database. It works in conjunction 
with the `cache-service` for READ access. The UPDATE/ADD & DELETE operations
are done directly called by the UI microservice. The access to Postgress is using the reactive r2dbc
driver.

note: this microservice depends with the Kafka to send notifications to the `cache-service` when
a modifications has been executed.


## Introduction

This is a microservice that stores all system parametres and variables.
We can define as follows:

A parameter is a value that normally does not change during a long time or during the day and many microservices use it frequently for their operation:

Some system parameters examples could be:
- System date (that could be different of the server machine date). This date is used not just for auditing but for calculations, example interests.
- Reprocess system date. This is used when the system need to do some re-procesor for past date without altering present dates.
- Fix exchange between peso and dollar or other currencies.
- Fix rates: TIIE, inflation, etc.
- Etc.

A variable is like a param, but it is calculated dynamically at query time for a formula.

note : Future versions of this microservice will include Phyton formulas defined in the UDFRun microservice.

## Use it with cache

Since the microservices queries the parameters many times during te day and optimize the database access; this microservice
works in conjunction with the `cache-service` to keep them in memory.

To solve the problem to keep in sync the values stored in the database versus the values in memory in the Cache 
microservice i.e, be the same values in the memory Redis cache parameters and the values stored
in Postgres DB, every time a parameter is changed this microservice (`param-service`) sends an event to be 
listened by the `cache-service` in order to invalidate the memory value in Redis and the next time it is 
queried the value is re-read from the database.


### Send events

Send a Event via  **Kafka**

#### Event Request

The **Event Request** is a **JSON** with the follow properties:

* **username:** The name of the user that generates the event.
* **correlationId:** This id helps to a listener application to follow a track of events. This id is generated by the Zuul API Gateway and keep the same until all micro services involved in the transaction finished.  It is important this trasaction for the Zipkin and Graylog montior servers.
* **eventType:** This event type tell if our event will be stored or not, its a **enum** that accepts these values:
  * DB_STORE: Store only into a data base.
  * FILE_STORE: Store only into a .TXT file.
  * FULL_STORE: Store into a data base and .TXT file.
  * NON_STORE: No store the event.
* **eventName:** This is the name of the event for example: *saveUser.*
* **applicationName**: Is the name of the micro service or front end application that generates the event.
* **coreName**: Is the group which it belongs the application name.  In other words is the topic that the listener will suscribe.
* **body:** The body is the action of the event, if we create a user the body is the result of create a new user.

*__Example:__*

```json
{
    "username":"user1",
    "correlationId": "saveUser_1",
    "eventType":"FULL_STORE",
    "eventName":"saveUser",
    "applicationName":"userServices",
    "eventBody":{
        "notificaFacultad": "NOTIFICA_IAM",
        "datos": {
          "interno": false, 
          "activo": true, 
          "administrador": false, 
          "id": 55, 
          "idUsuario": 501, 
          "nombreUsuario": "adACME", 
          "nombre": "Mickey", 
          "apellido": "Mouse", 
          "telefono": "5591495040", 
          "mail": "admin@esmas.com.mx",
          "fechaIngreso":"2022-04-18", 
          "zonaHoraria":"America/Mexico", 
          "usuarioModificacion":"adminACME", 
          "fechaModificacion":2022-04-22T17:27:14.899735009, 
          "grupos": [], 
          "companias":[],
          "areas":[], 
          "name":"adACME", 
          "attributes": {}, 
          "fullName":"Mickey Mouse", 
          "zoneInfo":"America/Mexico", 
          "authorities":[], 
          "givenName"="Mickey", 
          "familyName"="Mouse", 
          "phoneNumber":"5591495040", 
          "preferredUsername":"adACME", 
          "updatedAt":2022-04-22T17:27:14.899735009Z, 
          "claims": {}, 
          "email=admin@esmas.com.mx", 
          "address": {}
        }
    }
}
```

#### Kafka

#### Produce

This microservice does NOT produce event, it is just a listener

##### Produce

To send a **Event** via **kafka** we need to modify our Spring Boot application, we need to add new 
dependencies and configuration, *__YOU DON'T NEED INSTALL KAFKA__*. Kafka is installed **Kafka** so if you 
produce events you only need to connect to the existing **Kafka**.


### System parameters database

All parameters are stored in paramDB in Postgres.

A separate Postgres image is created for paramDB:

* A script called 01_init.sh is run when the image is created and creates the paramDB with a new user.
* The microservice uses Flyway to create the tables. The scrip is stored in /resource/db/migration


### Params queries from PostgresDB

This microservice utilizes PostgresDB to store the parameters, GraphQL as an API to query parameters
an QueryDsl as repository.

For more information see example:

spring-graphql-examples or visit link:

https://github.com/hantsy/spring-graphql-sample

Or the official repository (see examples) for Spring for GraphQL

https://github.com/spring-projects/spring-graphql

### Flyway

note: This docker algo generated the PosgressDB, paramDB.

Or a better method is to use the docker dash board to start and stop the application.

```
  IF EXISTS (SELECT FROM pg_database WHERE datname = 'paramdb') THEN
      CREATE USER $APP_DB_USER WITH PASSWORD '$APP_DB_PASS';
      GRANT ALL PRIVILEGES ON DATABASE $APP_DB_NAME TO $APP_DB_USER;
      RAISE NOTICE 'Database already exists';  -- optional
  ELSE
    CREATE USER $APP_DB_USER WITH PASSWORD '$APP_DB_PASS';
    CREATE DATABASE $APP_DB_NAME;
    GRANT ALL PRIVILEGES ON DATABASE $APP_DB_NAME TO $APP_DB_USER;
    \connect $APP_DB_NAME $APP_DB_USER
  END IF;
```

Original
```
#!/bin/bash
set -e
export PGPASSWORD=$POSTGRES_PASSWORD;
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
  CREATE USER $APP_DB_USER WITH PASSWORD '$APP_DB_PASS';
  CREATE DATABASE $APP_DB_NAME;
  GRANT ALL PRIVILEGES ON DATABASE $APP_DB_NAME TO $APP_DB_USER;
  \connect $APP_DB_NAME $APP_DB_USER
  BEGIN;

  COMMIT;
EOSQL
```



### Create the image manually

```
./gradlew bootBuildImage
```

### Publish the image to GitHub manually

```
./gradlew bootBuildImage \
   --imageName ghcr.io/rlegorreta/param-service \
   --publishImage \
   -PregistryUrl=ghcr.io \
   -PregistryUsername=rlegorreta \
   -PregistryToken=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
```

### Publish the image to GitHub from the IntelliJ

To publish the image to GitHub from the IDE IntelliJ a file inside the directory `.github/workflows/commit-stage.yml`
was created.

To validate the manifest file for kubernetes run the following command:

```
kubeval --strict -d k8s
```

This file compiles de project, test it (for this project is disabled for some bug), test vulnerabilities running
skype, commits the code, sends a report of vulnerabilities, creates the image and lastly push the container image.

<img height="340" src="./images/commit-stage.png" width="550"/>

For detail information see `.github/workflows/commit-stage.yml` file.


### Run the image inside the Docker desktop

```
docker run \
    --net ailegorretaNet \
    -p 8350:8350 \
    -e SPRING_PROFILES_ACTIVE=local \
    param-service
```

Or a better method use the `docker-compose` tool. Go to the directory `ailegorreta-deployment/docker-platform` and run
the command:

```
docker-compose up
```

## Run inside Kubernetes

### Manually

If we do not use the `Tilt`tool nd want to do it manually, first we need to create the image:

Fist step:

```
./gradlew bootBuildImage
```

Second step:

Then we have to load the image inside the minikube executing the command:

```
image load ailegorreta/param-service --profile ailegorreta 
```

To verify that the image has been loaded we can execute the command that lists all minikube images:

```
kubectl get pods --all-namespaces -o jsonpath="{..image}" | tr -s '[[:space:]]' '\n' | sort | uniq -c\n
```

Third step:

Then execute the deployment defined in the file `k8s/deployment.yml` with the command:

```
kubectl apply -f k8s/deployment.yml
```

And after the deployment can be deleted executing:

```
kubectl apply -f k8s/deployment.yml
```

Fourth step:

For service discovery we need to create a service applying with the file: `k8s/service.yml` executing the command:

```
kubectl apply -f k8s/service.yml
```

And after the process we can delete the service executing:

```
kubectl deltete -f k8s/service.yml
```

Fifth step:

If we want to use the project outside kubernetes we have to forward the port as follows:

```
kubectl port-forward service/config-service 8350:80
```

Appendix:

If we want to see the logs for this `pod` we can execute the following command:

```
kubectl logs deployment/param-service
```

### Using Tilt tool

To avoid all these boilerplate steps is much better and faster to use the `Tilt` tool as follows: first create see the
file located in the root directory of the proyect called `TiltFile`. This file has the content:

```
# Tilt file for param-service
# Build
custom_build(
    # Name of the container image
    ref = 'param-service',
    # Command to build the container image
    command = './gradlew bootBuildImage --imageName $EXPECTED_REF',
    # Files to watch that trigger a new build
    deps = ['build.gradle', 'src']
)

# Deploy
k8s_yaml(['k8s/deployment.yml', 'k8s/service.yml'])

# Manage
k8s_resource('param-service', port_forwards=['8350'])
```

To execute all five steps manually we just need to execute the command:

```
tilt up
```

In order to see the log of the deployment process please visit the following URL:

```
http://localhost:10350
```

Or execute outside Tilt the command:

```
kubectl logs deployment/param-service
```

In order to undeploy everything just execute the command:

```
tilt down
```

To run inside a docker desktop the microservice need to use http://cach-service:8350 path


### Reference Documentation
This microservice uses the recent Spring Gateway :

* [Spring Boot Gateway](https://cloud.spring.io/spring-cloud-gateway/reference/html/)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/docs/3.0.1/maven-plugin/reference/html/)
* [Config Client Quick Start](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_client_side_usage)
* [Spring Boot Actuator](https://docs.spring.io/spring-boot/docs/3.0.1/reference/htmlsingle/#production-ready)

### Links to Springboot 3 Observability

https://tanzu.vmware.com/developer/guides/observability-reactive-spring-boot-3/

Baeldung:

https://www.baeldung.com/spring-boot-3-observability



### Contact AI Legorreta

Feel free to reach out to AI Legorreta on [web page](https://legosoft.com.mx).


Version: 2.0.0
©LegoSoft Soluciones, S.C., 2023
